<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>from pya import *
import pya, sys, copy

topcell = None
layout = None
dbu = None

LayerSiN = None
LayerTextN = None
LayerPinRecN = None
LayerDevRecN = None
LayerFbrTgtN = None
LayerErrorN = None
LayerINTERCONNECTN = None
# initialize the arrays to keep track of layout objects
# Configure variables to draw structures in the presently selected cell:
lv = pya.Application.instance().main_window().current_view()
if lv == None:
  raise Exception("No view selected")
# Find the currently selected layout.
ly = pya.Application.instance().main_window().current_view().active_cellview().layout() 
if ly == None:
  raise Exception("No layout")
# find the currently selected cell:
topcell = pya.Application.instance().main_window().current_view().active_cellview().cell
if topcell == None:
  raise Exception("No cell")
# fetch the database parameters
dbu = ly.dbu

# Define layers based on PDK_functions:
LayerSiN = ly.layer(LayerSi)
LayerPinRecN = ly.layer(LayerPinRec)
LayerDevRecN = ly.layer(LayerDevRec)
LayerFbrTgtN = ly.layer(LayerFbrTgt)
LayerErrorN = ly.layer(LayerError)

# initialize the arrays to keep track of layout objects
reset_Optical_classes()
optical_components = []
optical_waveguides = []
optical_pins = []
optical_nets = []
layout_errors = []

# extract the circuit netlist from the physical layout:
optical_waveguides, optical_components = netlist_extraction(topcell)[:2]

# create a list of all the waveguides and components
temp_list = optical_waveguides + optical_components



"""
####JUST FOR REF. DELETE AFTER USE#####

Component        pins   x   y
ebeam_gc_te1550 [1, 0] 3.0 14.0
ebeam_gc_te1550 [3, 2] 3.0 141.0
ebeam_y_1550 [4, 5, 6] 10.4 141.0
ebeam_y_1550 [7, 8, 9] 10.4 14.0

They should get same pins for waveguides and components
tuples are not equal to lists
"""

#a list to store connected objects
list_of_obj = []

class connected_object:
  current_node = None
  parent_node = None
  child_nodes = []
  
  def __init__(self, parent,current, possible_child_nodes):
    self.current_node = current
    self.parent_node = parent
    for each in possible_child_nodes:
      #if each is not current node or parent node then test its relationship
      if(each != current and each!=parent):  
        result = [list(each_item) for each_item in self.function_connected(current, each)]
        if(len(result)&gt;0):
          self.child_nodes.append(each)
        
  # function to check if two components/waveguides are connected
  def function_connected(self,a,b):
    pins_a = self.return_pins(a)
    pins_b = self.return_pins(b)
    lists = [pins_a, pins_b]
    g = set.intersection(*[set(tuple(x) for x in y) for y in lists])
    return g
    
  #extract pins' coordinates of a component
  def return_pins(self,component):
    component_pins = []
    #if it is a waveguide
    if(isinstance(component, Optical_waveguide)== True):
      first_pt = component.points[0]
      last_pt = component.points[-1]
      for each in optical_pins:
        if([each.x,each.y] == first_pt or [each.x, each.y] == last_pt):
          component_pins.append([each.x, each.y])
    
    # if it is not a waveguide
    elif(isinstance(component, Optical_component)== True):
    #gc's the first one is the pin
      for i in component.pins:
        component_pins.append([optical_pins[i].x, optical_pins[i].y])
    
    return component_pins
  

#result = [list(each) for each in function_connected(optical_waveguides[0], optical_components[3])]
#if there are items in result then they are connected
for each in temp_list:
  current = each
  parent = None
#find if its parent is in the list_of_obj
  for each_obj in list_of_obj:
    if(current in each_obj.child_nodes):
      parent = each_obj
      break
  #add the object to list_of_obj
  list_of_obj.append(connected_object(parent, current, temp_list))

</text>
</klayout-macro>
