<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut>Ctrl+Shift+R</shortcut>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>"""
This file is part of the SiEPIC_EBeam_PDK
by Jaspreet Jhoja (c) 2016

This Python file implements a Graphical User Interface(GUI) for Monte-Carlo Simulations.

Version history:


Jaspreet Jhoja 2016/03/19 
 - Added param varitions for Within Wafer.
 - 
 
Jaspreet Jhoja 2016/03/18
 - Integrated with MC scripts
 - Provides a choice for the type of MC simulation: - mc_dtd and mc_wtw
 - edit_completed data validation for fields with nm units
 - instant input validation for other fields

Jaspreet Jhoja 2016/03/13 
 - Verifies the field input and highlight the unacceptable input.
 - Does not require tk8.6 and tcl8.6

Jaspreet Jhoja 2016/03/11 
 - Empty GUI with no functionality.
 - Requires tk8.6 and tcl 8.6 to work
 
 """
 
from pya import *
import pya, sys, copy

datalist = [] # list to store data from all fields
datadict ={} #dictionary storing all info
objlist = []#list of data objects
clear = []#12 clears should be there
topcell = None
layout = None
dbu = None

LayerSiN = None
LayerTextN = None
LayerPinRecN = None
LayerDevRecN = None
LayerFbrTgtN = None
LayerErrorN = None
LayerINTERCONNECTN = None
# initialize the arrays to keep track of layout objects
# Configure variables to draw structures in the presently selected cell:
lv = pya.Application.instance().main_window().current_view()
if lv == None:
  raise Exception("No view selected")
# Find the currently selected layout.
ly = pya.Application.instance().main_window().current_view().active_cellview().layout() 
if ly == None:
  raise Exception("No layout")
# find the currently selected cell:
topcell = pya.Application.instance().main_window().current_view().active_cellview().cell
if topcell == None:
  raise Exception("No cell")
# fetch the database parameters
dbu = ly.dbu

# Define layers based on PDK_functions:
LayerSiN = ly.layer(LayerSi)
LayerPinRecN = ly.layer(LayerPinRec)
LayerDevRecN = ly.layer(LayerDevRec)
LayerFbrTgtN = ly.layer(LayerFbrTgt)
LayerErrorN = ly.layer(LayerError)

# initialize the arrays to keep track of layout objects
reset_Optical_classes()
optical_components = []
optical_waveguides = []
optical_pins = []
optical_nets = []
layout_errors = []

# Record a transaction, to enable "undo"
lv.transaction("Object resizing")



# extract the circuit netlist from the physical layout:
optical_waveguides, optical_components = netlist_extraction(topcell)[:2]


if lv.has_transient_object_selection() == False:
  v = pya.MessageBox.warning("No transient selection", "Hover the mouse (transient selection) over the object to which you wish to snap to.\nEnsure transient selection is enabled in Settings - Applications - Selection.", pya.MessageBox.Ok)
else:
  # find the transient selection:
  print("found selection")
  o_transient_iter = lv.each_object_selected_transient()
  o_transient = next(o_transient_iter)  # returns ObjectInstPath[].
  escape = 0
  shape = o_transient.shape
  cell = o_transient.shape.cell
  #object_selection = []
  #for inst in topcell.each_inst():
  #  print("Cell: %s" % (inst.cell.basic_name() ) )
  #  if inst.cell.basic_name() in Waveguide_Types:
  #    n = len(object_selection)
  #    object_selection.append( pya.ObjectInstPath() )
  #    object_selection[n].top = topcell.cell_index()
  #    object_selection[n].append_path(pya.InstElement.new(inst))
  # Select the newly added objects
  #lv.object_selection = object_selection # returns ObjectInstPath[].
  
  
  cell.set_property("Waveguide_Type", "ROUND_PATH")
  Waveguide_Type = cell.property("Waveguide_Type")
  # Configure the library to use for the waveguide type.
  if Waveguide_Type == "ROUND_PATH":
    Waveguide_Lib = "Basic"
  
  
  
  points = path_to_points(shape.path)
  segments = []
  for i in range(len(points)):
    if(i&gt;0):
      pair = [points[i-1],points[i]]
      segments.append(pair)
  
  seg_orientation = []
  for each in segments:
    if(each[0][0] == each[1][0]):
      seg_orientation.append("vertical")
    elif(each[0][1] == each[1][1]):
      seg_orientation.append("horizontal")
  
  
  prop_points = points
  seg_propagation = []
  #+x, -x , +y , -y
  for each in segments:
    index = prop_points.index(each[0])
    prop = ""
    
    if(index == 0): 
      index = index+1
      element_idx = index+1
     #look at the second index
    else:
      element_idx = index-1
    
    x1 = prop_points[index][0]
    y1 = prop_points[index][1]
    x2 = prop_points[element_idx][0]
    y2 = prop_points[element_idx][1]
    
    if(x1 == x2):
      if(y1&lt;y2):
        prop = "+y"
      elif(y1&gt;y2):
        prop = "-y"
        #their x have same value means they are propagating along y axis  
    elif(y1 == y2):
      if(x1&lt;x2):
        prop = "-x"
      elif(x1&gt;x2):
        prop = "+x"
    print(index)
    print(element_idx)
    print(prop)
    seg_propagation.append(prop)
        # y have same values along x axis
      
  wdg = QWidget()
  #wdg = QDialog(pya.Application.instance().main_window())
  wdg.setAttribute(pya.Qt.WA_DeleteOnClose)
  wdg.setWindowTitle("Waveguide resizer")
  
  if sys.platform.startswith('linux'):
      # Linux-specific code here...
    titlefont = QFont("Arial", 11, QFont.Bold, False)
    
  elif sys.platform.startswith('darwin'):
      # OSX specific
    titlefont = QFont("Arial", 13, QFont.Bold, False)
        
  elif sys.platform.startswith('win'):
    titlefont = QFont("Arial", 9, QFont.Bold, False)
  
  #titlefont = QFont("Arial", 9, QFont.Bold, False)
  hbox = QVBoxLayout(wdg)
  
  wdg.setFixedSize(650, 200)
  
  def selection(self):
    #make a list of these to show them
    global segments, seg_orientation
    lf1text1.setText(str(abs(segments[parameters.currentIndex][0][0] - segments[parameters.currentIndex][1][0])*dbu + abs(segments[parameters.currentIndex][0][1] - segments[parameters.currentIndex][1][1])*dbu))
    lf1text2.setText(str(seg_orientation[parameters.currentIndex]))
  
  #Left Frame top section
  lframe1 = QFrame()
  lframe1.setFrameShape(QFrame.StyledPanel)
  lframe1.setStyleSheet("background-color: white;")
  lf1title = QLabel('Current Path Length (microns): %s' % str(shape.path_length()*dbu))
  parameters = QComboBox()
  #add vertices as params
  params = []
  for each in range(len(segments)):
    params.append("segment %s  points:  %s  - %s" %(str(each), str(tuple(segments[each][0])), str(tuple(segments[each][1]))))
    
  
  
  parameters.addItems(params)
  parameters.currentIndexChanged(selection)
  parameters.setFixedWidth(400)
  parameters.setStyleSheet("background-color: white;") 
  lf1label1 = QLabel('Segment length: ')
  lf1label2 = QLabel('Segment Orientation: ')
  
  
  lf1label3 = QLabel('New length (microns): ')
  lf1text1 = QLineEdit()
  lf1text1.setAccessibleName('lf1text1')
  #lf1text1.setAccessibleDescription('within_wafer_width')
  lf1text2 = QLineEdit()
  lf1text2.setAccessibleName('lf1text2')
  #lf1text2.setAccessibleDescription('within_wafer_thickness')
  lf1text3 = QLineEdit()
  lf1text3.setAccessibleName('lf1text3')
  #lf1text3.setAccessibleDescription('within_wafer_correlation')
  
  def button(self):
    global points, copy_pts, diff
    copy_pts = copy.deepcopy(points)
    index = parameters.currentIndex
    p1 = copy_pts[copy_pts.index(segments[index][0])]
    p2 = copy_pts[copy_pts.index(segments[index][1])]
    diff = float(lf1text3.text) - shape.path_length()*dbu
    diff = diff/dbu
    prop = seg_propagation[index]
    if(prop == "+x" or prop == "-x"):
      print("moving x")
      copy_pts[copy_pts.index(segments[index][0])][0] = copy_pts[copy_pts.index(segments[index][0])][0] + diff/2 
      copy_pts[copy_pts.index(segments[index][1])][0] = copy_pts[copy_pts.index(segments[index][1])][0] + diff/2
    elif(prop == "+y" or prop == "-y"):
      print("moving y")
      copy_pts[copy_pts.index(segments[index][0])][1] = copy_pts[copy_pts.index(segments[index][0])][1] + diff/2 
      copy_pts[copy_pts.index(segments[index][1])][1] = copy_pts[copy_pts.index(segments[index][1])][1] + diff/2   
    print("pushed", p1, p2)
    path_obj = cell.pcell_parameters_by_name()['path']
    wg_width = path_obj.width
    radius =  cell.pcell_parameters()[1]
    layout_waveguide_abs(topcell, LayerSi, points_mult(copy_pts,dbu), wg_width, radius)
    cell.delete()
    wdg.destroy()
    
  
  ok = QPushButton("OK")
  ok.clicked(button)
  
  lf1form = QGridLayout()
  lf1form.addWidget(lf1title,0,0)
  lf1form.addWidget(lf1label3, 1,0)
  lf1form.addWidget(lf1text3, 1,1)
  lf1form.addWidget(parameters,2,0)
  lf1form.addWidget(lf1label1, 3,0)
  lf1form.addWidget(lf1text1, 3,1)
  lf1form.addWidget(lf1label2, 4,0)
  lf1form.addWidget(lf1text2, 4,1)
  lf1form.addWidget(ok, 5,1)
  lframe1.setLayout(lf1form)
  
  
  #ok.clicked(button)
  
  #Left Vertical splitter
  leftsplitter = QSplitter(Qt.Vertical)
  leftsplitter.addWidget(lframe1)
  
  leftsplitter.setSizes([500,400,10])
  
  #Main Window Splitter
  splitter1 = QSplitter(Qt.Horizontal)
  textedit = QTextEdit()
  splitter1.addWidget(leftsplitter)
  splitter1.setSizes([400,400])
  
  #top frame
  container = QWidget()
  hbox.addWidget(splitter1)
  objlist.append(lf1text1)
  objlist.append(lf1text2)
  objlist.append(lf1text3)
  
  #filling gui
  #for each in range(len(objlist)):
   # objlist[each].setText(sample_data[each])
  selection(None)
  #editcheck()
  #Changes:
  #
  
  wdg.show()</text>
</klayout-macro>
