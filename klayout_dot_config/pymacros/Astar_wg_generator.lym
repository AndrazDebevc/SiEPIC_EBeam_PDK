<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>
 # Python script
# A* algorithm for waveguide path generation

"""
This file is part of the SiEPIC_EBeam_PDK
by Jaspreet Jhoja (c) 2015

This Python file takes an input for start and end point coordinates and generates an optimal path without crossing or overlapping the existing waveguides.

uses:
 - the SiEPIC EBeam GDS Library
 - the SiEPIC EBeam PCell Library

Version history:
Jaspreet Jhoja          2015/12/10
- Reduced grid density and fast path generation.
- Minimum grid coordinate increment is 10um. There should always be a zero at ones place therefore coordinates like 20.1, 21, 1, 5, 2, 111 are not valid
- Valid coordinates should look like 0, 10, 20.0, 110, 120, 300 
- Also check the other waveguides' coordinates. They should also be aligned to the grid.



Jaspreet Jhoja          2015/12/03
 - Takes Manual coordinate input, if no coordinates are set,
   then the script automatically extract coordinates from the 
   start_pt and end_pt text.      
 - Allow input for desired gap between waveguides
 - only works for waveguide width of 500nm 
 -  usually takes 10-15 seconds, depending on the complexity of the obstacle
"""

# 
# Python script to create a layout for testing a double-bus ring resonator.
# uses:
#  - the SiEPIC EBeam GDS Library
#  - the SiEPIC EBeam PCell Library
# deletes everything first
#be patient, usually it takes around 14-15 seconds depending on the complexity of the obstacles







import pya
import sys, ast, copy, operator, heapq, time, string, collections
from math import sqrt
from collections import deque
global opened, closed, child_nodes, listtoget, barred_points, gap, restricted_points


opened = [] # stores all the generated but yet to visit nodes
closed = [] #stores all the visited nodes
child_nodes = [] # stores all the child nodes
barred_points = [] #points on 1d lines which are already taken
starting_pt=[0, 0]  #starting X and Y coordinates
goal_pt = [0,0]  #Goal C and Y coordinates
gap = 1000 #desired gap between waveguides. Default: 0.5um
wg_points = [] #list containing all the final backtracked path points



def find_points(topcell, LayerTextN):
  # find_automated_measurement_labels(topcell, LayerTextN)
  t = []
  dbu = topcell.layout().dbu
  iter = topcell.begin_shapes_rec(LayerTextN)
  i=0
  while not(iter.at_end()):
    if iter.shape().is_text():
      text = iter.shape().text
      if text.string.find("start_pt") > -1:
        i+=1
        text2 = iter.shape().text.transformed(iter.itrans())
        t.append([text2.x, text2.y])
        #t += "label: %s, location: (%s, %s) <br>" %(text.string, text2.x*dbu, text2.y*dbu )
      if text.string.find("end_pt") > -1:
        i+=1
        text2 = iter.shape().text.transformed(iter.itrans())
        t.append([text2.x, text2.y])
        #t += "label: %s, location: (%s, %s) <br>" %(text.string, text2.x*dbu, text2.y*dbu )
    iter.next()
 # t += "<br>*** Number of automated measurement labels: %s.<br>" % i
  return t

if(starting_pt == goal_pt):
  topcell = pya.Application.instance().main_window().current_view().active_cellview().cell
  LayerTextN = topcell.layout().layer(LayerText)
  t = find_points(topcell, LayerTextN)
  starting_pt = t[1]
  goal_pt = t[0]



# Configure variables to draw structures in the presently selected cell:
lv = pya.Application.instance().main_window().current_view()
if lv == None:
  raise Exception("No view selected")
# Find the currently selected layout.
layout = pya.Application.instance().main_window().current_view().active_cellview().layout() 
if layout == None:
  raise Exception("No layout")
cv = pya.Application.instance().main_window().current_view().active_cellview()
# find the currently selected cell:

if topcell == None:
  raise Exception("No cell")
# fetch the database parameters
dbu = layout.dbu

# Define layers based on PDK_functions:
LayerSiN = layout.layer(LayerSi)
LayerTextN = layout.layer(LayerText)
LayerPinRecN = layout.layer(LayerPinRec)
LayerDevRecN = layout.layer(LayerDevRec)
LayerFbrTgtN = layout.layer(LayerFbrTgt)
LayerErrorN = layout.layer(LayerError)
LayerINTERCONNECTN = layout.layer(LayerINTERCONNECT)
LayerSi = pya.LayerInfo(1, 0)
#LayerSiN = cell.layout().layer(LayerSi)
fpLayer = pya.LayerInfo(99, 0)
#fpLayerN = cell.layout().layer(fpLayer)
TextLayer = pya.LayerInfo(10, 0)
#TextLayerN = cell.layout().layer(TextLayer)

# Clear the previous errors:
clear_ErrorLayer(topcell, LayerErrorN)


############################################################################
####  PHASE -1 : Extract points which are already taken ####################
############################################################################

# initialize the arrays to keep track of layout objects
reset_Optical_classes()
optical_components = []
optical_waveguides = []
optical_pins = []
optical_nets = []

# Create a Results Database
rdb_i = lv.create_rdb("SiEPIC_Verification")
rdb = lv.rdb(rdb_i)
rdb.top_cell_name = topcell.name
rdb_cell = rdb.create_cell(topcell.name)

# Search the layout for the components and waveguides:
# Search the arrays to identify all the nets:
optical_waveguides, optical_components, clock_find_all_components, clock_find_all_waveguides, clock_identify_all_nets \
  = netlist_extraction(topcell)

b_points = []  #list containing extracted waveguide points and their widths
for i in optical_waveguides:
  converted_points = i.points
  b_points.append([i.wg_width*1e3,converted_points])

bar_points = []

for i in b_points:
  a = []
  for j in i[1]:
    a.append([int(j[0]*1e-3), int(j[1]*1e-3)])
  bar_points.append(a)
  
restricted_points = []
def addin(x):
    global restricted_points
    restricted_points = restricted_points +[[x[0],x[1]]]
    
for i in bar_points:
    for j in i:
        if(i.index(j)>0):
            ind = i.index(j)
            x = i[ind-1]
            y = i[ind]
          #  print x,y
            z= copy.deepcopy(x)
            diffx=x[0]-y[0]
            diffy=x[1]-y[1]

            if(diffx<0):
                multx = -1
            else:
                multx = 1

            if(diffy <0):
                multy = -1
            else:
                multy = 1


          #  print abs(diffx),abs(diffy)
            if(abs(diffx)>0):
                for p in range(int(abs(diffx)/10)):
                    z[0] = z[0] - (multx *10)
                    addin(z)
                    for q in range(int(abs(diffy)/10)):
                        z[1] = z[1] - (multy *10)
                        addin(z)
                    z[1] = x[1]
            else:
                for q in range(int(abs(diffy)/10)):
                        z[1] = z[1] - (multy *10)
                        addin(z)
        else:
         addin(j)
    
#barred_points contains the data about the restricted areas

  
###########################################################################  
############ PHASE -2 : DEFINING NODE AND A* Algorithm ####################
###########################################################################


class AStar:
    def distBetween(self,current,neighbor):
        return 10

    def heuristicEstimate(self,start,goal):
        hvalue = (abs(start[0]-goal[0]) + abs(start[1]-goal[1]))#*1.001
        return hvalue

    def neighborNodes(self,current):
      clist = []

      ch1 = copy.deepcopy(current)
      gc1 = gScore[str(current)] + 10
      ch1[0] = ch1[0]+10

      
      ch2 = copy.deepcopy(current)
      ch2[0] = ch2[0]-10

      ch3 = copy.deepcopy(current)
      ch3[1] = ch3[1]+10
      
      ch4 = copy.deepcopy(current)
      ch4[1] = ch4[1]-10
      if(ch1 not in restricted_points):
          clist.append(ch1)

      if(ch2 not in restricted_points):    
          clist.append(ch2)

      if(ch3 not in restricted_points):
          clist.append(ch3)
      if(ch4 not in restricted_points):
          clist.append(ch4)
      

      gScore.update({str(ch1): gc1})
      gScore.update({str(ch2): gc1})
      gScore.update({str(ch3):gc1})
      gScore.update({str(ch4): gc1})
      
      return clist
    
    def reconstructPath(self,cameFrom,start, goal):
        try:
            global path
            path = deque()

            node = (goal)
            path.appendleft(node)
            while True:
            #    print node
                node = cameFrom[str(node)]
                path.appendleft((node))
                if(node == str(start)):
                    return path
        except Exception as e:
            None
    
    def getLowest(self,openSet,fScore):
        global lowest
        lowest = float("inf")
        lowestNode = None
        for node in openSet:
            if fScore[str(node)] < lowest:
                lowest = fScore[str(node)]
                lowestNode = node
        return lowestNode

    def aStar(self,start,goal):
        global gScore, fScore, openSet, closedSet, current, cameFrom
        cameFrom = {}
        openSet = set()
        openSet.add(str(start))
        closedSet = set()
        gScore = {}
        fScore = {}
        gScore.update({str(start): 0})
        fScore.update({str(start): 0})
        gScore[str(start)] = 0
        fScore[str(start)] = gScore[str(start)] + self.heuristicEstimate(start,goal)
        while len(openSet) != 0:
            current = self.getLowest(openSet,fScore)
            current = ast.literal_eval(current)
            if current == goal:
                return self.reconstructPath(cameFrom,start,goal)
                #return "lol"
            openSet.remove(str(current))
            closedSet.add(str(current))
            for neighbor in self.neighborNodes(current):
                tentative_gScore = gScore[str(current)] + self.distBetween(current,neighbor)
                if str(neighbor) in closedSet and tentative_gScore >= gScore[str(neighbor)]:
                    continue
                if str(neighbor) not in closedSet or tentative_gScore < gScore[str(neighbor)]:
                    cameFrom[str(neighbor)] = current
                    gScore[str(neighbor)] = tentative_gScore
                    fScore[str(neighbor)] = gScore[str(neighbor)] + self.heuristicEstimate(neighbor,goal)
                    if str(neighbor) not in openSet:
                        openSet.add(str(neighbor))

        return "no path found"

a=AStar()
a.aStar([int(starting_pt[0]*1e-3),int(starting_pt[1]*1e-3)],[int(goal_pt[0]*1e-3),int(goal_pt[1]*1e-3)])
#b = a.reconstructPath(cameFrom, starting_pt,goal_pt)
 
  
def draw(): #This function is responsible for drawing on the star

        cell = pya.Application.instance().main_window().current_view().active_cellview().cell
      #  cell = cell.layout().create_cell("MZI_TE_Variations")
        #cell = pya.Application.instance().main_window().current_view().active_cellview().cell
        L1 = layout_waveguide_abs(cell, LayerSi, wg_points , 0.5, 5)
  
wg_points = path

draw()
 
 </text>
</klayout-macro>
