<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>SiEPIC: Verification and Netlist generation</description>
 <version>0.1.2</version>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut>V</shortcut>
 <show-in-menu>true</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># Python script
# SiEPIC_EBeam_Verification

"""
This file is part of the SiEPIC_EBeam_PDK
by Lukas Chrostowski (c) 2015

This Python file implements layout verification and netlist extraction


Version history:

Lukas Chrostowski 2015/11/11
 - Optical_net class
 - find all LayerSi paths and waveguides, and save optical net vertices 
 - find all PinRec paths
 - find all DevRec polygons and boxes
 - check_waveguides
   - waveguide bend minimum
   - paths with corners (more than 2 points)
   - bend radius less than specified
 - error marker layer and class; clear errors

Lukas Chrostowski 2015/11/12
 - determining where pins/waveguides overlap to generate a netlist
 - initial Spice output for components including waveguides and nets.
 - check nets &amp; components
   - incorrect number of nets connected to a component (disconnected, or too many)
 
Lukas Chrostowski           2015/11/15
 - fix for Python 3.4: print("xxx")
 - moved some functions from here, to the common "SiEPIC_EBeam_functions file, so they are accessible elsewhere.
 - added pin# text label on PinRec layer; sort pins in Spice output using these names.

Lukas Chrostowski           2015/11/16
 - fixes for component pin_type = Optical IO / FbrTgt being incorrectly handled; added Optical_pin.pin_type

Lukas Chrostowski           2015/11/17
 - debugging &amp; fixing Verification problems

Lukas Chrostowski           2015/11/18
 - removed need for numpy.array

Lukas Chrostowski           2015/11/19
 - moved some functions to SiEPIC_EBeam_functions

 
"""


import pya
import math
#import numpy
MODULE_NUMPY = False
import math
import string


  
def flag_waveguide_error(dpoints, text, optical_waveguide, topcell):
  # global variable "layout_errors" of class "Layout_error" used for storing all the errors.
  a1 = []
  for p in dpoints:
    a1.append (pya.Point(int(p[0]), int(p[1])))
  path = pya.Path(a1, optical_waveguide.wg_width*4/dbu)
  topcell.shapes(LayerErrorN).insert(path)
  x,y = xy_mean_mult(dpoints, dbu)
  layout_errors.append(Layout_error(text, x, y) )
  print (text)
  wtext.insertHtml('%s&lt;br&gt;' %text)


def check_waveguides(optical_waveguides, topcell, error_layer):
  # check waveguides for basic errors.
  num_errors=0

  for o in optical_waveguides:
    found_error = False

    # Check for paths with &gt; 2 vertices
    if (o.wg_type == 0 and o.num_points &gt; 2):
      text = "  *** Layout error.  Waveguide path (%s, %s): Only 2 points allowed in a path. Convert to a waveguide (ROUND_PATH) if necessary. " \
            % ( o.points[0][0]*dbu, o.points[0][1]*dbu) 
      dpoints = o.points
      found_error = True
      flag_waveguide_error(dpoints, text, o, topcell)

    # find the minimum segment to make sure that the bends have large enough radius
    if (o.wg_type == 1):
      # first segment:
      segment = distance_xy ( o.points[0], o.points[1] ) 
      if segment &lt; o.radius:
        text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for waveguide end." % (segment, o.radius)
        dpoints=[ o.points[0], o.points[1] ] 
        found_error = True 
        flag_waveguide_error(dpoints, text, o, topcell)
      # last segment:
      segment = distance_xy ( o.points[len(o.points)-2], o.points[len(o.points)-1] ) 
      if segment &lt; o.radius:
        text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for waveguide end." % (segment, o.radius)
        dpoints=[ o.points[len(o.points)-2], o.points[len(o.points)-1] ]
        flag_waveguide_error(dpoints, text, o, topcell)
        found_error = True
      # go through each of the middle segments:
      for j in range(1, len(o.points)-2):
        segment = distance_xy ( o.points[j], o.points[j+1] ) 
        if segment &lt; 2*o.radius and segment != 0:
          text =  "  *** Layout warning.  Not enough space (%s) to accommodate the desired bend radius (%s) for a mid-segment." % (segment, o.radius)
          dpoints=[ o.points[j], o.points[j+1] ] 
          flag_waveguide_error(dpoints, text, o, topcell)
          found_error = True

      # Check for waveguides with too few bend points
      recommended_points = points_per_circle(o.radius)
      if o.bend_pts &lt; 0.75 * recommended_points:
        text =  "  *** Layout warning.  Waveguide bends should have at least %s points per circle for a %s micron radius." \
                     % (int(recommended_points), o.radius)
        dpoints=o.points
        found_error = True
        flag_waveguide_error(dpoints, text, o, topcell)
              




def check_components(cell, LayerDevRecN):
  # function to go through all the cells
  # check that the cell has at most ONE DevRec shape.  
  return False
 
 

def flag_component_error(box, text, x, y):
  # global variable "layout_errors" of class "Layout_error" used for storing all the errors.
  topcell.shapes(LayerErrorN).insert(box)
  layout_errors.append(Layout_error(text, x, y) )
  print(text)
  wtext.insertHtml('%s&lt;br&gt;' %text)


def check_connectivity(optical_components, topcell, LayerErrorN):
  # Make sure that all pins/waveguides are connected, i.e., dangling pins/waveguides.
  # Flag disconnected pins
  # Flag disconnected waveguides

  for k in range(0,len(optical_components)):
    if optical_components[k].npins != len(optical_components[k].nets):
      text = "  *** Connectivity error.  Mismatch between the number of pins (%s) on the component (%s, %s) at (%s, %s), and the number of nets (%s)." \
            % ( optical_components[k].npins, optical_components[k].component, optical_components[k].index, \
                optical_components[k].x, optical_components[k].y, len(optical_components[k].nets) )
      bbox = layout.cell(optical_components[k].instance).bbox()
      box = bbox.transformed(pya.Trans(optical_components[k].rotate, optical_components[k].flip, \
                optical_components[k].x/dbu,optical_components[k].y/dbu))
#      flag_component_error(box, text, optical_components[k].x, optical_components[k].y)

      # go through all the pins in the component, and check if they aren't assigned to a net
      for m in range(0,optical_components[k].npins):
        pin = optical_pins[optical_components[k].pins[m]]
        if pin.net == 0 and pin.pin_type == 1:  # disconnected pin on a pin_type = 1 (component)
          text = "  *** Found disconnected pin #%s at (%s, %s)." % (pin.index, pin.x*dbu, pin.y*dbu)
          box = pya.Box(pin.x-3000, pin.y-3000, pin.x+3000, pin.y+3000)
#          flag_component_error(box, text, pin.x*dbu, pin.y*dbu)

  for pin in optical_pins:
    if pin.net == -1 and pin.pin_type != 2:  # disconnected pin not on a pin_type = 2 (optical IO)
      text = "  *** Found disconnected pin #%s, type %s, at (%s, %s), component #%s {%s}" \
          % (pin.index, pin.pin_type, pin.x*dbu, pin.y*dbu, \
             pin.component_n, optical_components[pin.component_n].component)
      box = pya.Box(pin.x-3000, pin.y-3000, pin.x+3000, pin.y+3000)
      flag_component_error(box, text, pin.x*dbu, pin.y*dbu)

  for w1 in optical_waveguides:
    # examine the beginning of the waveguide:
    if w1.net1 == -1:
      text = "  *** Found disconnected waveguide at (%s, %s), net1" \
          % (w1.points[0][0]*dbu, w1.points[0][1]*dbu)
      flag_waveguide_error( [w1.points[0], w1.points[1]], text, optical_waveguides[w1.index], topcell)
    # examine the end of the waveguide:
    if w1.net2 == -1:
      text = "  *** Found disconnected waveguide at (%s, %s), net2" \
          % (w1.points[len(w1.points)-1][0]*dbu, w1.points[len(w1.points)-1][1]*dbu)
      flag_waveguide_error([w1.points[len(w1.points)-1], w1.points[len(w1.points)-2]], \
               text, optical_waveguides[w1.index], topcell)

def list_optical_components(optical_components):
  # list all Optical_component objects from an array
  # input array, optical_components
  # example output:         
  # X_grating_coupler_1 N$7 N$6 grating_coupler library="custom/genericcml" sch_x=-1.42 sch_y=-0.265 sch_r=0 sch_f=false

  for o in optical_components:
    nets_str = ""
    for n in o.nets:
      nets_str += " N$" + str(n)
    flip = ' sch_f=true' if o.flip else ''
    if o.rotate &gt; 0:
      rotate = ' sch_r=%s' % str(o.rotate)
    else:
      rotate = ''
#    t = '%s %s %s library="%s" lay_x=%s lay_y=%s sch_x=%s sch_y=%s %s%s'  % \
#         ( "X"+o.component+"_"+str(o.index), nets_str, o.component, o.library, str (o.x * 1e-6), o.y * 1e-6, o.x, o.y, rotate, flip)
    t = '  %s %s %s library="%s" sch_x=%s sch_y=%s %s%s'  % \
         ( "X"+o.component+"_"+str(o.index), nets_str, o.component, o.library, eng_str(o.x * 5e-2), eng_str(o.y * 5e-2), rotate, flip)
    print (t)
    wtext.insertHtml('%s&lt;br&gt;' %t)

def list_optical_waveguides(list_optical_waveguides):
  # list all Optical_waveguides objects from an array
  # input array, optical_waveguides
  # example output:         
  # X5 9 10 ebeam_wg_strip_1550 library="Design kits/ebeam_v1.0" wg_length=7.86299e-06 wg_width=5.085e-07 sch_x=-1.42 sch_y=-0.265

  for o in list_optical_waveguides:
    nets_str = "N$%s N$%s" %(o.net1, o.net2)
    x,y = xy_mean_mult(o.points, dbu)
#    t = '%s %s %s library="%s" wg_length=%s wg_width=%s lay_x=%s lay_y=%s sch_x=%5.3f sch_y=%5.3f'  % \
#           ( "Xwg" + str(o.index), nets_str, o.component, o.library, eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), \
#             eng_str(x * 1e-6), eng_str(y * 1e-6), x, y)
    t = '  %s %s %s library="%s" wg_length=%s wg_width=%s sch_x=%s sch_y=%s'  % \
           ( "Xwg" + str(o.index), nets_str, o.component, o.library, \
             eng_str(o.length*1e-6), eng_str(o.wg_width*1e-6), eng_str(x * 5e-2), eng_str(y * 5e-2))
    print (t)
    wtext.insertHtml('%s&lt;br&gt;' %t)
    

def gen_ui():
  global wdg
  
  # If the window is already here, destroy it and start over again.
  if 'wdg' in globals():
    if wdg is not None and not wdg.destroyed():
      wdg.destroy()
  global wtext

  def button_clicked(checked):
    """ Event handler: "OK" button clicked """
    wdg.destroy()

  wdg = pya.QDialog(pya.Application.instance().main_window())

  wdg.setAttribute(pya.Qt.WA_DeleteOnClose)
  wdg.setWindowTitle("SiEPIC-EBeam-PDK Verification and Netlist Generation")

  wdg.resize(1200, 2500)
  wdg.move(1, 1)

  grid = pya.QGridLayout(wdg)

  windowlabel1 = pya.QLabel(wdg)
  windowlabel1.setText("Verification output:")
  wtext = pya.QTextEdit(wdg)
  wtext.enabled = True
  wtext.setText('')
  wtext.LineWrapMode = pya.QTextEdit.NoWrap

  ok = pya.QPushButton("OK", wdg)
  ok.clicked(button_clicked)   # attach the event handler
  netlist = pya.QPushButton("Netlist Export", wdg) # not implemented

  grid.addWidget(windowlabel1, 0, 0, 1, 3)
  grid.addWidget(wtext, 1, 1, 3, 3)
  grid.addWidget(netlist, 4, 2)
  grid.addWidget(ok, 4, 3)

  grid.setRowStretch(3, 1)
  grid.setColumnStretch(1, 1)

  wdg.show()



# ************************************************************************
# ************************************************************************
#  Main script:
# ************************************************************************
# ************************************************************************

# Create a GUI for the output:
gen_ui()
print(wdg)
wtext.insertHtml('Running SiEPIC-EBeam-PDK Verification and Netlist Generation.&lt;br&gt;')


# Configure variables to draw structures in the presently selected cell:
lv = pya.Application.instance().main_window().current_view()
if lv == None:
  raise Exception("No view selected")
# Find the currently selected layout.
layout = pya.Application.instance().main_window().current_view().active_cellview().layout() 
if layout == None:
  raise Exception("No layout")
# find the currently selected cell:
topcell = pya.Application.instance().main_window().current_view().active_cellview().cell
if topcell == None:
  raise Exception("No cell")
# fetch the database parameters
dbu = layout.dbu


# Define layers based on PDK_functions:
LayerSiN = layout.layer(LayerSi)
LayerTextN = layout.layer(LayerText)
LayerPinRecN = layout.layer(LayerPinRec)
LayerDevRecN = layout.layer(LayerDevRec)
LayerFbrTgtN = layout.layer(LayerFbrTgt)
LayerErrorN = layout.layer(LayerError)
LayerINTERCONNECTN = layout.layer(LayerINTERCONNECT)

# Clear the previous errors:
clear_ErrorLayer(topcell, LayerErrorN)

# initialize the arrays to keep track of layout objects
reset_Optical_classes()
optical_components = []
optical_waveguides = []
optical_pins = []
optical_nets = []

# Search the layout for the components and waveguides:
print ("")
print ("* calling find_all_components() – DevRec:")
find_all_components(topcell, LayerDevRecN, LayerPinRecN, LayerFbrTgtN)
print ("")
print ("* calling find_all_waveguides():")
find_all_waveguides(topcell, LayerSiN)

print ("")
print ("* print_Optical_all, after find_all_{components, waveguides}:")
print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)

# Search the arrays to identify all the nets:
print ("")
print ("* calling identify_all_nets():")
identify_all_nets(optical_pins, optical_waveguides, optical_components)

print ("")
print ("print_Optical_all, after identify_all_nets:")
print_Optical_all(optical_components, optical_waveguides, optical_pins, optical_nets)

# Check the layout for errors, using the above arrays:
print ("")
print ("Checking layout for errors: ")
wtext.insertHtml('&lt;br&gt;* Checking layout for errors:&lt;br&gt;&lt;br&gt;')
layout_errors=[]
# Check components - overlapping
check_components(topcell, LayerDevRecN)
# Check waveguides for waveguide-specific problems:
check_waveguides(optical_waveguides, topcell, LayerErrorN)
# Check connectivity between components and waveguides:
check_connectivity(optical_components, topcell, LayerErrorN)
lv.add_missing_layers()

print ("*** Number of errors found: %s." % len(layout_errors) )
wtext.insertHtml('&lt;br&gt;*** Number of errors found: %s.&lt;br&gt;' % len(layout_errors) )


# Output the Spice netlist:
text_Spice = generate_Spice_file(topcell, optical_waveguides, optical_components)
wtext.insertPlainText(text_Spice)

# Find the automated measurement coordinates:
wtext.insertHtml('&lt;br&gt;* Automated measurement coordinates:&lt;br&gt;&lt;br&gt;')
print ("")
print ("Automated measurement coordinates: ")
print ("")
t = find_automated_measurement_labels(topcell, LayerTextN)
wtext.insertHtml (t)

# Done
wtext.insertHtml('&lt;br&gt;Done.&lt;br&gt;')
print ("")
print ("Done. ")
print ("")




</text>
</klayout-macro>
